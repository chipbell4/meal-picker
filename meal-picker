#!/usr/bin/env python3

import argparse
from datetime import date, datetime, timedelta
import random
from typing import Optional
import apple

import domain


def add_grocery(item: str, note: str = ""):
    return apple.add_reminder("Groceries", item, note)


def add_meal_schedule_to_calendar_starting_on(
    when: date, schedule: domain.MealSchedule
):
    meal_time_lookup = {
        "breakfast": 8,
        "lunch": 12,
        "dinner": 17,
    }

    for days_ahead, daily_schedule in enumerate(schedule.days):
        current_day = when + timedelta(days=days_ahead)

        for meal_name, hour in meal_time_lookup.items():
            # If there's no meal set for this meal time, skip it
            meal: Optional[domain.Meal] = getattr(daily_schedule, meal_name)
            if meal is None:
                continue

            summary = meal.name
            description = ", ".join(meal.ingredients + meal.pantry)
            meal_time = datetime.combine(current_day, datetime.min.time()).replace(
                hour=hour
            )
            apple.add_event(summary, meal_time, description)


# Parse Arguments
parser = argparse.ArgumentParser(
    prog="meal-picker",
    description="Picks meals randomly from a list, adding the ingredients to our grocery list",
)
parser.add_argument("-n", "--number-of-meals", default=1, type=int)
parser.add_argument("-s", "--seed", default=int(datetime.now().timestamp()), type=int)
parser.add_argument("-r", "--add-to-reminders", default=False, action="store_true")
parser.add_argument("-d", "--debug", default=False, action="store_true")
args = parser.parse_args()

# Pick a subset of meals, respecting seed so we can re-run and actually apply
# once we get a set we like
random.seed(args.seed)
db = domain.MealDatabase()
schedule = domain.MealSchedule()
schedule.fill_schedule(args.number_of_meals, db)
print("-" * 80)
print(str(schedule))
print("-" * 80)

print(f"Seed was {args.seed}")

# Add each ingredient to the list, but first try to deduplicate (and replace
# with a count). Moreover, keep track of the meals associated with each
# ingredient so that we can add that as a note. Keep track of the unique set of
# pantry items needed so that we can remind ourselves at the end
grocery_list = domain.GroceryList()
grocery_list.add_schedule(schedule)

if args.add_to_reminders:
    tomorrow = date.today() + timedelta(days=1)
    add_meal_schedule_to_calendar_starting_on(tomorrow, schedule)

for item in grocery_list:
    reminder_title = item.name
    reminder_notes = ", ".join(item.meals)
    if item.count > 1:
        reminder_title += f" (x{item.count})"

    if args.debug:
        print(f"  Adding item {reminder_title} : {reminder_notes}")
    if args.add_to_reminders:
        add_grocery(reminder_title, reminder_notes)

print()
print("Pantry items required:")
for pantry_item in schedule.pantry_items:
    print(f"  - {pantry_item}")
print()

if not args.add_to_reminders:
    print("Dry-run only. Set -r to actually save to Reminders")

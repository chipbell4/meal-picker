#!/usr/bin/env python3

import argparse
import datetime
import json
import random
import subprocess
from collections import defaultdict
import sys

import domain


def asrun(ascript):
    osa = subprocess.run(
        ["/usr/bin/osascript", "-"], input=ascript, text=True, capture_output=True
    )
    if osa.returncode == 0:
        return osa.stdout.rstrip()
    else:
        raise ChildProcessError(f"AppleScript: {osa.stderr.rstrip()}")


def add_item(list_name: str, item: str, note: str = ""):
    with open("add-item.scpt", "r") as f:
        template = f.read()

    script = (
        template.replace("%LIST%", list_name)
        .replace("%ITEM%", item)
        .replace("%NOTE%", note)
    )

    return asrun(script)


def add_grocery(item: str, note: str = ""):
    return add_item("Groceries", item, note)


def add_meal(meal: str, ingredients: list[str]):
    note = " ".join(ingredients)
    add_item("Meals", meal, note)


# Parse Arguments
parser = argparse.ArgumentParser(
    prog="meal-picker",
    description="Picks meals randomly from a list, adding the ingredients to our grocery list",
)
parser.add_argument("-n", "--number-of-meals", default=1, type=int)
parser.add_argument(
    "-s", "--seed", default=int(datetime.datetime.now().timestamp()), type=int
)
parser.add_argument("-r", "--add-to-reminders", default=False, action="store_true")
parser.add_argument("-d", "--debug", default=False, action="store_true")
args = parser.parse_args()

# Pick a subset of meals, respecting seed so we can re-run and actually apply
# once we get a set we like
random.seed(args.seed)
chosen_meals = domain.pick_random_meals(args.number_of_meals)
print("-" * 80)
for meal in chosen_meals:
    print(meal.name)
print("-" * 80)

print(f"Seed was {args.seed}")

# Add each ingredient to the list, but first try to deduplicate (and replace
# with a count). Moreover, keep track of the meals associated with each
# ingredient so that we can add that as a note. Keep track of the unique set of
# pantry items needed so that we can remind ourselves at the end
ingredient_counts = defaultdict(int)
ingredient_meal_lookup = defaultdict(list)
required_pantry_items = domain.required_pantry_for(chosen_meals)
for meal in chosen_meals:
    ingredients = meal.ingredients
    pantry_items = meal.pantry

    if args.add_to_reminders:
        add_meal(meal, ingredients + pantry_items)

    for ingredient in ingredients:
        ingredient_counts[ingredient] += 1
        ingredient_meal_lookup[ingredient].append(meal)

ingredients_to_add = sorted(ingredient_counts.keys())
for ingredient in ingredients_to_add:
    reminder_title = ingredient
    reminder_notes = ", ".join(
        [meal.name for meal in ingredient_meal_lookup[ingredient]]
    )
    count = ingredient_counts[ingredient]

    if count > 1:
        reminder_title += f" (x{count})"

    if args.debug:
        print(f"  Adding item {reminder_title} : {reminder_notes}")
    if args.add_to_reminders:
        add_grocery(reminder_title, reminder_notes)

print()
print("Pantry items required:")
for pantry_item in required_pantry_items:
    print(f"  - {pantry_item}")
print()

print("Dry-run only. Set -r to actually save to Reminders")
